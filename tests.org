#+STARTUP: showstars indent inlineimages
#+PROPERTY: header-args :mkdirp yes
The order these are written in has two purposes:
1. When a bug is introduced, a fairly minimal example should be found
   by these tests.
2. If somebody else wants to use this project as an exercise, the
   tests will be presented in a reasonable order to perform TDD.
   Fleshing out features just enough to:
   1. Build other features upon them.
   2. See the design mistakes while trying to build on them.
   3. See the mistakes early enough that they are easy to fix.
* 01 Parser Foundations
#+BEGIN_SRC text :tangle tests.d/01-Parser-Foundations/README.md
The `Parser`'s job is simply to parse and then display the parsed
equation.  These tests introduce numbers, variables, the 4
main operators, and parenthesis.
#+END_SRC
** 01 Basics
#+BEGIN_SRC text :tangle tests.d/01-Parser-Foundations/01-Basics/README.md
Test the basic literals and some non-recursive parsing.
#+END_SRC
*** 01 Number
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/01-Basics/01-parser-number.input
3
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/01-Basics/01-parser-number.output
3
#+END_SRC
*** 02 Variable
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/01-Basics/02-parser-variable.input
a
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/01-Basics/02-parser-variable.output
a
#+END_SRC
*** 03 Sum
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/01-Basics/03-parser-sum.input
1+2
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/01-Basics/03-parser-sum.output
1+2
#+END_SRC
*** 04 Difference
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/01-Basics/04-parser-difference.input
2-1
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/01-Basics/04-parser-difference.output
2-1
#+END_SRC
*** 05 Product
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/01-Basics/05-parser-prod.input
1*2
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/01-Basics/05-parser-prod.output
1*2
#+END_SRC
*** 06 Fraction
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/01-Basics/06-parser-frac.input
1/2
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/01-Basics/06-parser-frac.output
1/2
#+END_SRC
** 02 Parentheses
#+BEGIN_SRC text :tangle tests.d/01-Parser-Foundations/02-Parentheses/README.md
Parentheses are not part of the parsed tree and so will not be re-printed
when they are not necessary.  Here are some small examples of cases
where they are and are not necessary.

No simplification is being performed by the parser.  These parentheses
are not being "removed", they are simply redundant and so when the
parse-tree is printed, they are not present where they are meaningless.
#+END_SRC
*** 01 Group
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/02-Parentheses/01-parser-group.input
(1+1)/2
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/02-Parentheses/01-parser-group.output
(1+1)/2
#+END_SRC
*** 02 unGroup
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/02-Parentheses/02-parser-ungroup.input
(1*2)+3
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/02-Parentheses/02-parser-ungroup.output
1*2+3
#+END_SRC
*** 03 unGroup
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/02-Parentheses/03-parser-ungroup.input
1+(2+3)
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/02-Parentheses/03-parser-ungroup.output
1+2+3
#+END_SRC
*** 04 Group
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/02-Parentheses/04-parser-group.input
1-(2+3)
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/02-Parentheses/04-parser-group.output
1-(2+3)
#+END_SRC
*** 05 unGroup
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/02-Parentheses/05-parser-ungroup.input
1-2+3
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/02-Parentheses/05-parser-ungroup.output
1-2+3
#+END_SRC
*** 06 unGroup
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/02-Parentheses/06-parser-ungroup.input
1*(2*3)
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/02-Parentheses/06-parser-ungroup.output
1*2*3
#+END_SRC
*** 07 Group
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/02-Parentheses/07-parser-group.input
1/(2*3)
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/02-Parentheses/07-parser-group.output
1/(2*3)
#+END_SRC
*** 08 unGroup
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/02-Parentheses/08-parser-ungroup.input
1/2*3
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/02-Parentheses/08-parser-ungroup.output
1/2*3
#+END_SRC
*** 09 unGroup
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/02-Parentheses/09-parser-ungroup.input
1-2*3
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/02-Parentheses/09-parser-ungroup.output
1-2*3
#+END_SRC
** 03 Basic With Vars
#+BEGIN_SRC text :tangle tests.d/01-Parser-Foundations/03-Basic-Vars/README.md
Verify that variables parse-able in all of the places that numbers
are, and in any combination.
#+END_SRC
*** 01 Sum Variables
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/03-Basic-Vars/01-parser-sum_vars.input
x+y
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/03-Basic-Vars/01-parser-sum_vars.output
x+y
#+END_SRC
*** 02 Difference Variables
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/03-Basic-Vars/02-parser-difference_vars.input
x-y
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/03-Basic-Vars/02-parser-difference_vars.output
x-y
#+END_SRC
*** 03 Product Variables
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/03-Basic-Vars/03-parser-prod_vars.input
x*y
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/03-Basic-Vars/03-parser-prod_vars.output
x*y
#+END_SRC
*** 04 Product Variables Without Number
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/03-Basic-Vars/04-parser-prod_vars_without.input
xy
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/03-Basic-Vars/04-parser-prod_vars_without.output
x*y
#+END_SRC
*** 05 Product Variable with Number
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/03-Basic-Vars/05-parser-prod_var_num.input
3x
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/03-Basic-Vars/05-parser-prod_var_num.output
3*x
#+END_SRC
*** 06 Fraction Variables
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/03-Basic-Vars/06-parser-frac_vars.input
x/y
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/03-Basic-Vars/06-parser-frac_vars.output
x/y
#+END_SRC
*** 07 Fraction Variable Bottom
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/03-Basic-Vars/07-parser-frac_var_bot.input
1/x
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/03-Basic-Vars/07-parser-frac_var_bot.output
1/x
#+END_SRC
*** 08 Fraction Variable Top
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/03-Basic-Vars/08-parser-frac_var_top.input
x/2
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/03-Basic-Vars/08-parser-frac_var_top.output
x/2
#+END_SRC
** 04 Number Features
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/04-Number-Features/README.md
Some compleatness tests on what numbers handle.
#+END_SRC
*** 01 Negatives
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/04-Number-Features/01-parser-negitive.input
-3
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/04-Number-Features/01-parser-negitive.output
-3
#+END_SRC
*** 02 Decimal
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/04-Number-Features/02-parser-decimal.input
1.2
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/04-Number-Features/02-parser-decimal.output
1.2
#+END_SRC
** 05 Variable Features
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/05-Variable-Features/README.md
Check that variables can be subscripted correctly.
#+END_SRC
*** 01 Variable Names 1
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/05-Variable-Features/01-parser-var_names_1.input
x_1
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/05-Variable-Features/01-parser-var_names_1.output
x_1
#+END_SRC
*** 02 Variable Names 2
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/05-Variable-Features/02-parser-var_names_2.input
x_{name}
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/05-Variable-Features/02-parser-var_names_2.output
x_{name}
#+END_SRC
** 06 Completeness tests
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/README.md
Negitive tests are often more valueable than positive test in
verifying behavior correctness.  These tests should be pretty self
explanatory as to what's wrong if they fail.
#+END_SRC
*** 01 Don't Simplify in the parser
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/01-README.md
Verifying that the parser isn't mutating the parsed input.
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/01-parser-no_lex.input
y+x
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/01-parser-no_lex.output
y+x
#+END_SRC
*** 02 Multi Digit Number
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/02-parser-number_multi_digit.input
1234
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/02-parser-number_multi_digit.output
1234
#+END_SRC
*** 03 Variable Subtraction
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/03-parser-minus_variable.input
1-x
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/03-parser-minus_variable.output
1-x
#+END_SRC
*** 04 Variable Unary Minus 
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/04-parser-negitive_variable.input
1*-x
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/04-parser-negitive_variable.output
1*-1*x
#+END_SRC
*** 05 Variable Unary Minus 2
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/05-parser-negitive_variable_2.input
1/-x
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/05-parser-negitive_variable_2.output
1/(-1*x)
#+END_SRC
*** 06 Variable Unary Minus 3
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/06-parser-negitive_variable_3.input
1+-x
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/06-parser-negitive_variable_3.output
1+-1*x
#+END_SRC
*** 07 No Unary Plus
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/07-parser-no_unary_plus.input
1++x
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/07-parser-no_unary_plus.output
Parse Error
#+END_SRC
*** 08 Dangling Open
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/08-parser-dangle_open.input
(
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/08-parser-dangle_open.output
Parse Error
#+END_SRC
*** 09 Dangling Close
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/09-parser-dangle_close.input
)
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/09-parser-dangle_close.output
Parse Error
#+END_SRC
*** 10 Complex Dangling Open
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/10-parser-dangle_open_2.input
1+(3+
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/10-parser-dangle_open_2.output
Parse Error
#+END_SRC
*** 11 Complex Dangling Close
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/11-parser-dangle_close_2.input
1+x)
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/11-parser-dangle_close_2.output
Parse Error
#+END_SRC
*** 12 Terminal Division
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/12-parser-terminal_division.input
1+4/
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/12-parser-terminal_division.output
Parse Error
#+END_SRC
*** 13 Terminal Multiplication
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/13-parser-terminal_mult.input
1+x*
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/13-parser-terminal_mult.output
Parse Error
#+END_SRC
*** 14 Terminal Addition
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/14-parser-termnial_add.input
1+
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/14-parser-termnial_add.output
Parse Error
#+END_SRC
*** 15 Terminal Subtraction
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/15-parser-terminal_sub.input
1+x-
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/15-parser-terminal_sub.output
Parse Error
#+END_SRC
*** 16 Subscript Addition
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/16-parser-sub_adition.input
x_+
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/16-parser-sub_adition.output
x_+
#+END_SRC
*** 17 Subscript Parenthesis
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/17-parser-sub_paren.input
x_)
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/17-parser-sub_paren.output
x_)
#+END_SRC
*** 18 Sum Same Variable
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/18-parser-sum_same_variable.input
x+x
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/01-Parser-Foundations/06-Completeness/18-parser-sum_same_variable.output
x+x
#+END_SRC
* 02 Simplifyer Foundations
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/README.md
This section mostly just checks for some basic simplifications and
arithmetic.  Forcing the build up of a "client" for the Parser's output.
#+END_SRC
** 01 Number
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/01-Numbers/01-simplifyer-number.input
3
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/01-Numbers/01-simplifyer-number.output
3
#+END_SRC
** 02 Constant Reduction
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/02-Constant-Reduction/README.md
Multiplying and adding zero along with multiplying by one can be simply reduced.
#+END_SRC
*** 01 One Product 1
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/02-Constant-Reduction/01-simplifyer-one_prod.input
1*3
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/02-Constant-Reduction/01-simplifyer-one_prod.output
3
#+END_SRC
*** 02 One Product 2
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/02-Constant-Reduction/02-simplifyer-one_prod_2.input
3*1
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/02-Constant-Reduction/02-simplifyer-one_prod_2.output
3
#+END_SRC
*** 03 One Product 3
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/02-Constant-Reduction/03-simplifyer-one_prod_3.input
1*1*3*1*1
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/02-Constant-Reduction/03-simplifyer-one_prod_3.output
3
#+END_SRC
*** 04 One Product 4
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/02-Constant-Reduction/04-simplifyer-one_prod_4.input
1*1*3*1*x*1
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/02-Constant-Reduction/04-simplifyer-one_prod_4.output
3*x
#+END_SRC
*** 05 Zero Product 1
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/02-Constant-Reduction/05-simplifyer-zero_prod.input
0*3
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/02-Constant-Reduction/05-simplifyer-zero_prod.output
0
#+END_SRC
*** 06 Zero Product 2
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/02-Constant-Reduction/06-simplifyer-zero_prod_2.input
3*0
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/02-Constant-Reduction/06-simplifyer-zero_prod_2.output
0
#+END_SRC
*** 07 Zero Product 3
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/02-Constant-Reduction/07-simplifyer-zero_prod_3.input
1*1*3*1*0*1
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/02-Constant-Reduction/07-simplifyer-zero_prod_3.output
0
#+END_SRC
*** 08 Zero Product 4
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/02-Constant-Reduction/08-simplifyer-zero_prod_4.input
1*0*3*1*x*1
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/02-Constant-Reduction/08-simplifyer-zero_prod_4.output
0
#+END_SRC
*** 09 Zero Product 5
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/02-Constant-Reduction/09-simplifyer-zero_prod_5.input
0/x
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/02-Constant-Reduction/09-simplifyer-zero_prod_5.output
0
#+END_SRC
*** 10 Zero Sum
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/02-Constant-Reduction/10-simplifyer-zero_sum.input
0+x
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/02-Constant-Reduction/10-simplifyer-zero_sum.output
x
#+END_SRC
** 03 Arithmetic Reduction
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/03-Arithmetic-Reduction/README.md
Simple arithmetic can be performed.
#+END_SRC
*** 01 Arithmetic Addition
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/03-Arithmetic-Reduction/01-simplifyer-Arithmetic_Addition.input
1+2
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/03-Arithmetic-Reduction/01-simplifyer-Arithmetic_Addition.output
3
#+END_SRC
*** 02 Arithmetic Addition Big
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/03-Arithmetic-Reduction/02-simplifyer-Arithmetic_Adition_Big.input
1+2+3
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/03-Arithmetic-Reduction/02-simplifyer-Arithmetic_Adition_Big.output
6
#+END_SRC
*** 03 Arithmetic Multiplication
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/03-Arithmetic-Reduction/03-simplifyer-Arithmetic_Multiplication.input
1*2*3*4
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/03-Arithmetic-Reduction/03-simplifyer-Arithmetic_Multiplication.output
24
#+END_SRC
*** 04 Arithmetic Add and Mul
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/03-Arithmetic-Reduction/04-simplifyer-Arithmetic_Add_and_Mul.input
(1+2)*(3+4)
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/03-Arithmetic-Reduction/04-simplifyer-Arithmetic_Add_and_Mul.output
21
#+END_SRC
*** 05 Arithmetic also Div
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/03-Arithmetic-Reduction/05-simplifyer-Arithmetic_also_Div.input
(3*4)/(1+2)
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/03-Arithmetic-Reduction/05-simplifyer-Arithmetic_also_Div.output
4
#+END_SRC
*** 06 Arithmetic Subtraction
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/03-Arithmetic-Reduction/06-simplifyer-Arithmetic_Subtraction.input
2-1
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/03-Arithmetic-Reduction/06-simplifyer-Arithmetic_Subtraction.output
1
#+END_SRC
*** 07 Arithmetic Variable Subtraction
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/03-Arithmetic-Reduction/07-simplifyer-Arithmetic_Variable_Subtraction.input
0-x
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/03-Arithmetic-Reduction/07-simplifyer-Arithmetic_Variable_Subtraction.output
-1*x
#+END_SRC
** 04 Lexicographic Sorting
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/04-Lexicographic/README.md
Sort terms in decreasing lexicographic order.  This order is chosen so
that there is a canonical order both so that transform patters are
simpler and so that the tests have a single correct answer.

TODO: Explain this better. 
#+END_SRC
*** 01 Lexicographic Variables Order 1
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/04-Lexicographic/01-simplifyer-lex_var_1.input
x*3
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/04-Lexicographic/01-simplifyer-lex_var_1.output
3*x
#+END_SRC
*** 02 Lexicographic Variables Order 2
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/04-Lexicographic/02-simplifyer-lex_var_2.input
y*x
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/04-Lexicographic/02-simplifyer-lex_var_2.output
x*y
#+END_SRC
*** 03 Lexicographic Variables Order 3
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/04-Lexicographic/03-simplifyer-lex_var_3.input
x+2
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/04-Lexicographic/03-simplifyer-lex_var_3.output
2+x
#+END_SRC
*** 04 Lexicographic Variables Order 4
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/04-Lexicographic/04-simplifyer-lex_var_4.input
y*x*2
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/04-Lexicographic/04-simplifyer-lex_var_4.output
2*x*y
#+END_SRC
*** 05 Lexicographic Variables Order 5
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/04-Lexicographic/05-simplifyer-lex_var_5.input
y+x+2
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/04-Lexicographic/05-simplifyer-lex_var_5.output
2+x+y
#+END_SRC
*** 06 Lexicographic Variables Order 6
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/04-Lexicographic/06-simplifyer-lex_var_6.input
y*x+x*2
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/04-Lexicographic/06-simplifyer-lex_var_6.output
2*x+x*y
#+END_SRC
*** 07 Lexicographic Variables Order 7
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/04-Lexicographic/07-simplifyer-lex_var_7.input
(y+x)*(x+2)
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/04-Lexicographic/07-simplifyer-lex_var_7.output
(2+x)*(x+y)
#+END_SRC
*** 08 Lexicographic Variables Order 8
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/04-Lexicographic/08-simplifyer-lex_var_8.input
0+(x+4)(x+y+0)(1*x+2)(x+-1*1)(0*x+4+7+y)(x+3-3)
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/04-Lexicographic/08-simplifyer-lex_var_8.output
x*(-1+x)*(2+x)*(4+x)*(11+y)*(x+y)
#+END_SRC
** 05 Completeness Tests
*** 01 Division by Zero
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/05_Completeness/01-simplifyer-div_zero.input
1/0
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/05_Completeness/01-simplifyer-div_zero.output
\infty
#+END_SRC
*** 02 Negative Division by Zero
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/05_Completeness/02-simplifyer-div_zero_2.input
-1/0
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/05_Completeness/02-simplifyer-div_zero_2.output
-\infty
#+END_SRC
*** 03 Zero Division by Zero
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/05_Completeness/03-simplifyer-div_zero_3.input
0/0
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/02-Simplifier-Foundations/05_Completeness/03-simplifyer-div_zero_3.output
NaN
#+END_SRC
* 03 Parser Expansion
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/README.md
Parse some well known functions, constants, and operators.
#+END_SRC
** 01 Common Operators
*** 01 Square Root
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/01-Common-Operators/01-parser-square_root.input
\sqrt{3}
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/01-Common-Operators/01-parser-square_root.output
\sqrt{3}
#+END_SRC
*** 02 Square Root 2
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/01-Common-Operators/02-parser-square_root_2.input
\sqrt{-3}
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/01-Common-Operators/02-parser-square_root_2.output
\sqrt{-3}
#+END_SRC
*** 03 Natural Log
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/01-Common-Operators/03-parser-ln.input
\ln{3}
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/01-Common-Operators/03-parser-ln.output
\ln{3}
#+END_SRC
*** 04 Natural Log 2
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/01-Common-Operators/04-parser-ln.input
\ln{-3}
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/01-Common-Operators/04-parser-ln.output
\ln{-3}
#+END_SRC
*** 05 Natural Log 3
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/01-Common-Operators/05-parser-ln.input
\ln{3/4}
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/01-Common-Operators/05-parser-ln.output
\ln{3/4}
#+END_SRC
*** 06 N-Root
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/01-Common-Operators/06-parser-n_root.input
\sqrt[4]{3}
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/01-Common-Operators/06-parser-n_root.output
\sqrt[4]{3}
#+END_SRC
*** 07 N-Root 2
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/01-Common-Operators/07-parser-n_root_2.input
\sqrt[-4]{3}
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/01-Common-Operators/07-parser-n_root_2.output
\sqrt[-4]{3}
#+END_SRC
*** 08 N-Root 3
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/01-Common-Operators/08-parser-n_root_3.input
\sqrt[4/2]{3}
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/01-Common-Operators/08-parser-n_root_3.output
\sqrt[4/2]{3}
#+END_SRC
*** 09 Logarithm
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/01-Common-Operators/09-parser-log.input
\log_4{3}
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/01-Common-Operators/09-parser-log.output
\log_4{3}
#+END_SRC
*** 10 Logarithm 2
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/01-Common-Operators/10-parser-log_2.input
\log_(4/2){3}
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/01-Common-Operators/10-parser-log_2.output
\log_(4/2){3}
#+END_SRC
*** 11 Exponential Operator
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/01-Common-Operators/11-parser-pow.input
2^3
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/01-Common-Operators/11-parser-pow.output
2^3
#+END_SRC
*** 12 Exponential Operator 2 - Nesting
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/01-Common-Operators/12-parser-pow_2.input
2^3^4
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/01-Common-Operators/12-parser-pow_2.output
2^3^4
#+END_SRC
*** 13 Exponential Operator 3 - Unneeded Parenthesis
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/01-Common-Operators/13-parser-pow_3.input
2^(3^4)
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/01-Common-Operators/13-parser-pow_3.output
2^3^4
#+END_SRC
*** 14 Exponential Operator 4 - Negatives
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/01-Common-Operators/14-parser-pow_4.input
-3^4
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/01-Common-Operators/14-parser-pow_4.output
-3^4
#+END_SRC
*** 15 Exponential Operator 5 - Negatives
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/01-Common-Operators/15-parser-pow_5.input
3^-4
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/01-Common-Operators/15-parser-pow_5.output
3^-4
#+END_SRC
*** 16 Exponential Operator 6 - Subtraction
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/01-Common-Operators/16-parser-pow_6.input
2-3^4
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/01-Common-Operators/16-parser-pow_6.output
2-3^4
#+END_SRC
** 02 Known Constants
*** 01 Pi
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/02-Known-Constatns/01-README.md
The constant `pi` is half of the circle constant, `tau`.
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/02-Known-Constatns/01-parser-pi.input
\pi
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/02-Known-Constatns/01-parser-pi.output
\pi
#+END_SRC
*** 02 Phi
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/02-Known-Constatns/02-README.md
The constant `phi` is the Golden Ratio.
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/02-Known-Constatns/02-parser-phi.input
\phi
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/02-Known-Constatns/02-parser-phi.output
\phi
#+END_SRC
*** 03 i
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/02-Known-Constatns/03-README.md
The constant `i` is the imaginary unit.
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/02-Known-Constatns/03-parser-i.input
i
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/02-Known-Constatns/03-parser-i.output
i
#+END_SRC
** 03 Known Functions
*** 01 Exp Operator
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/03-Known-Functions/01-README.md
The function `exp` is the exponential function.  Also known as Euler's Number.
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/03-Known-Functions/01-parser-exp.input
\exp{3}
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/03-Known-Functions/01-parser-exp.output
\exp{3}
#+END_SRC
*** 02 Sin
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/03-Known-Functions/02-parser-sin.input
\sin{3}
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/03-Known-Functions/02-parser-sin.output
\sin{3}
#+END_SRC
*** 03 Cos
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/03-Known-Functions/03-parser-cos.input
\cos{3}
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/03-Known-Functions/03-parser-cos.output
\cos{3}
#+END_SRC
*** 04 Tan
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/03-Known-Functions/04-parser-tan.input
\tan{3}
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/03-Known-Functions/04-parser-tan.output
\tan{3}
#+END_SRC
** 04 Ignore Spaces
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/04-Ignore-Spaces/README.md
The parser is presumably well enough developed to have an internal
framework.  Ading whitespace removal should be easy at this point.  If
this is very hard, perhaps it's time for a refacting.
#+END_SRC
*** 01 Spaces in Addition
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/04-Ignore-Spaces/01-parser-spaces_addition.input
1 + 2
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/04-Ignore-Spaces/01-parser-spaces_addition.output
1+2
#+END_SRC
*** 02 Spaces in Multiplication
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/04-Ignore-Spaces/02-parser-spaces_multiplication.input
1 * 2
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/04-Ignore-Spaces/02-parser-spaces_multiplication.output
1*2
#+END_SRC
*** 03 Spaces in Implicit Multiplication
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/04-Ignore-Spaces/03-parser-spaces_multiplication_implicit.input
2 x
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/04-Ignore-Spaces/03-parser-spaces_multiplication_implicit.output
2*x
#+END_SRC
*** 04 Spaces Before Expression
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/04-Ignore-Spaces/04-parser-spaces_before_expresion.input
 3+2
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/04-Ignore-Spaces/04-parser-spaces_before_expresion.output
3+2
#+END_SRC
*** 05 Spaces Around Parenthesis
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/04-Ignore-Spaces/05-parser-spaces_parentheses.input
3+ ( 2*5 ) +2
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/04-Ignore-Spaces/05-parser-spaces_parentheses.output
3+2*5+2
#+END_SRC
*** 06 Spaces as Function Application
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/04-Ignore-Spaces/06-parser-spaces_function.input
\ln 3
#+END_SRC
#+BEGIN_SRC scheme :tangle tests.d/03-Parser-Expanding/04-Ignore-Spaces/06-parser-spaces_function.output
\ln{3}
#+END_SRC
